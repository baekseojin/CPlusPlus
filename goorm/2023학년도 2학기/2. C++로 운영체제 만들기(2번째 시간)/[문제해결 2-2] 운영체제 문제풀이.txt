< 실습문제 1. > 

(1) : P1 -> P4 -> P5 -> P2 -> P3 순서대로 실행된다. 

(2) : Request <= Need 여야 하는데 0 1 0 0 <= 0 0 0 0 이 만족하지 않으므로 오류 발생.

(3) : Request <= Need 여야 하는데 1 0 0 1 <= 0 7 5 0 이 만족하지 않으므로  오류 발생.

(4) : Request <= Need ( 0 1 0 0 <= 6 6 2 2 ) , Request <= Available ( 0 1 0 0 <= 2 1 0 0 ) 둘 다 만족하므로 Available은 ( 2 0 0 0 )이 되고 Allocation은 ( 0 1 3 4 ) , Need는 ( 6 5 2 2 ) 가 된다. 
이후 은행원 알고리즘을 수행하면
P1 -> P4 -> P5 -> 실행불가( Available < Need ) 라는 결과가 도출된다.


< 실습문제 2. > 

A, B

A는 a, c, d, b 순서대로 실행
B는 a, b, c 순서대로 실행
C는 d, b 순서대로 실행

 

< 실습문제 3. >

(1) 최댓값 : 24 / 최솟값 : 0

(2) 
최댓값이 24인 이유 : 작업 B를 3번 실행하면 count는 3이 된다. 이후 작업 A를 3번 실행하면 count는 24가 된다. 

최솟값이 0인 이유 : 작업 A를 2줄 실행 하면 count와 a가 0이다. 이 상태에서 작업 B의 코드 3줄을 실행하면 count와 b가 1이 된다. 이 상태에서 다시 작업 A로 돌아가 count = a를 실행하게 되면 count는 0이 된다. 이 과정을 반복하면 count는 0이 된다.  
 
 

< 실습문제 4. > 

(1) 가장 빨리 종료되는 프로세스 : A / 가장 늦게 종료되는 프로세스 : C
(2) CPU의 총 유휴시간 : 1 / 프로세스 C가 CPU 할당을 대기하는 총 시간 : 15


< 실습문제 5. > 

(1)

아니다. 
우선순위가 커도 가상실행시간으로 다음 실행 프로세스가 선택되기 때문이다.
 
우선순위는 가상실행시간에 영향은 줄 수 있을지라도 실행시간 때문에 절대적인 수치를 정해주는 것이 아니기 때문에 우선순위 값이 가장 큰 프로세스가 다음 실행 프로세스라고 할 수 없다. 

(2) 

P4(100) -> P3(150) -> P1(150) -> P2(200)