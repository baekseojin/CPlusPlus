---------- < 문제 1 > ----------

(1) 14bit / 15bit
(2) 216byte
(3) 11168
(4) 8220

페이지 크기: 1KB = 2^10 byte = 1024 byte
프로그램 크기: 9000 byte

(1) 가상 주소에 필요한 총 비트수와 실 주소에 필요한 총 비트 수를 순서대로 쓸 것. 

페이지 크기가 2^10 이므로 변위가 10bit임.

가상 주소 : 페이지 비트 + 변위 비트(4bit + 10bit)
페이지 비트는 어떻게 구하냐면 9000 / 1024하면 8.7이 나옴
그러면 일단 페이지 갯수가 9개 필요하잖아?
9를 2진수로 표시하려면 비트 4개가 필요함.
그래서 페이지 비트는 4bit이다.

물리 주소 : 프레임 비트 + 변위 비트(5bit + 10bit)
주기억장치에 총 32개의 페이지 프레임이 존재한다고 조건에 나와있음.
32 = 2^5 이므로 프레임 비트는 5bit이다. 

가상 주소에 필요한 총 비트수 : 4bit + 10bit = 14bit
실 주소에 필요한 총 비트수 : 5bit + 10bit = 15bit

(2) 내부 단편화가 발생한 용량을 바이트 단위로 쓸 것.

내부 단편화 = 프로그램에서 페이지를 최대한 다 채우고 남는 용량
9000 - (1024 * 8) = 808 byte

808byte 만큼 남았는데 1024byte의 페이지 공간에 808byte를 넣으면 
216byte 만큼의 내부 단편화 발생!

(3) 가상 주소 4000번지에 대한 실 주소를 쓸 것.

4000(가상주소) / 1024(페이지 크기) => 페이지 번호 : 3 / 변위값 : 928
페이지 번호가 3이면 프레임 번호는 10이다.
실 주소(물리 주소) : 페이지 크기 * 프레임 번호 + 변위값 이므로
1024 * 10 + 928 => 11168  

따라서 가상 주소 4000번지에 대한 실 주소는 11168 이다.


(4) 실 주소 3100번지에 대한 가상 주소를 쓸 것.

3100(실 주소) / 1024(페이지 크기) => 프레임 번호 : 3 / 변위값 : 28
프레임 번호가 3이면 페이지 번호는 8이다. 
가상 주소 : 페이지 크기 * 페이지 번호 + 변위값 이므로
1024 * 8 + 28 = 8220

따라서 실 주소 3100번지에 대한 가상 주소는 8220이다. 


---------- < 문제 2 > ----------

(1) 페이지 존재, 물리주소 7196 / 페이지 부재 / 페이지 존재, 물리주소 379
(2) 28

(1) 각각의 가상 주소에 대하여 페이지 부재(page fault) 여부를 밝히고, 물리 주소가 존재한다면 구하여 쓸 것.

ⓐ. 1052 
ⓑ. 2221
ⓒ. 5499

ⓐ.
1052(가상주소) / 1024(페이지 크기) = 1(페이지 번호) / 28(변위값)
페이지 번호가 1번인 것이 있으므로 페이지는 존재한다. 
이 가상 주소의 물리 주소(페이지 크기 * 프레임 번호 + 변위값)는
1024 * 7 + 28 = 7196
따라서 ⓐ의 페이지는 존재하고, 물리 주소는 7196이다. 

ⓑ. 
2221(가상 주소) / 1024(페이지 크기) = 2(페이지 번호) / 173(변위값)
페이지 번호가 2번인 것이 없으므로 페이지가 존재하지 않는다(페이지 부재).

ⓒ.
5499(가상 주소) / 1024(페이지 크기) = 5(페이지 번호) / 379(변위값)
페이지 번호가 5인 것이 있으므로 페이지는 존재한다.
이 가상 주소의 물리주소는
1024 * 0 + 379 = 379
따라서 ⓒ의 페이지는 존재하고, 물리주소는 379이다.



(2) 물리주소 3100에 대응되는 가상주소를 구하여 쓸 것.

3100(물리주소) / 1024(페이지 크기) = 3(프레임 번호) / 28(변위값)
프레임 번호 3 -> 페이지 번호 0에 대응된다.
가상 주소 = 페이지 크기 * 페이지 번호 + 변위값
1024 * 0 + 28 = 28
따라서 물리주소 3100에 대응되는 가상주소는 28이다.


---------- < 문제 3 > ----------

(1) 0, 5, 3, 2, 4, 1, 3, 4, 0, 3, 2, 5, 1, 1, 2, 4
(2) 12회

(1) 참조하는 페이지번호를 가장 먼저 참조된 페이지번호부터 차례대로 나열할 것.

오른쪽 쉬프트 연산을 하기 때문에 젤 오른쪽 비트가 1인 페이지가 가장 먼저 참조된다.
그렇다변 8번째 비트가 1인 페이지인 0, 5가 제일 먼저 참조된다.
그 다음은 3번 페이지가 7번째 비트가 1이기 때문에 그 다음으로 참조된다.

0, 5, 3, 2, 4, 1, 3, 4, 0, 3, 2, 5, 1, 1, 2, 4


(2) LRU 페이지 교체 알고리즘을 이용하여 (1)의 참조열을 처리하는 과정에서 페이지 부재 횟수를 쓸 것.

페이지 프레임이 3이므로 숫자 3개가 들어갈 수 있음.
LRU(Least Recently Used) 알고리즘을 사용해 페이지 부재 횟수를 계산하면 된다.
페이지 부재는 지금 페이지 번호가 그 전에 없으면 발생한다. (중복되지 않으면 페이지 부재)

0(1) -> 2(3) -> 3(4) -> 2(6) -> 1(8)
5(1) -> 4(4) -> 3(5) -> 1(7) -> 4(8)
3(2) -> 1(3) -> 0(5) -> 5(6) -> 2(8)

따라서 총 페이지 부재 횟수는 12회이다.


---------- < 문제 4 > ----------

다음의 16진수로 이루어진 가상주소를 차례대로 참조한다고 가정하자. 이 때, 주어진 물음에 답하시오. < E12C, 3A9D, A9D9, 7001, ACA1, C111, D321, B123 > 

(1) 가상주소에 대응하는 물리주소를 16진수를 이용하여 차례대로 쓸 것. 단, 변환되지 못하고 페이지 부재를 일으키는 가상주소는 "페이지 부재"라고 표시할 것. 

4096을 16진수로 바꾸면 1000이 나옴.
16진수 / 16진수 로 바로 계산함.

ⓐ E12C(가상주소) / 1000(페이지 크기) = E(페이지 번호), 12C(변위값)
페이지번호 E에 대응하는 프레임 번호는 3이다. 
따라서 가상주소 E12C의 물리주소는 3 * 1000 + 12C => 312C이다.

ⓑ 3A9D / 1000 = 3, A9D
페이지번호 3에 대응하는 프레임 번호는 10이다. 
따라서 가상주소 3A9D는 물리주소 AA9D로 바뀐다.

ⓒ 가상주소 A9D9 => 물리주소 59D9

ⓓ 가상주소 7001 => 물리주소 F001

ⓔ 가상주소 ACA1 => 물리주소 5CA1

ⓕ 가상주소 C111 => 페이지 번호 12에 해당하는 프레임이 없으므로 페이지 부재 발생.

ⓖ 가상주소 D321 => 페이지 번호 13에 해당하는 프레임이 없으므로 페이지 부재 발생.

ⓗ 가상주소 B123 => 물리주소 4123


(2) 가상주소 참조 후 페이지 부재를 해결하기 위하여 LRU 페이지 교체 알고리즘이 교체 대상으로 선택할 수 있는 페이지 프레임 번호를 모두 쓸 것.









